{
    "componentChunkName": "component---src-templates-article-tsx",
    "path": "/articles/a-reliable-case-for-unreliable-packets/",
    "result": {"data":{"markdownRemark":{"excerpt":"Packets in Roblox are ordered and reliable. That means that if you fire off events in this order: ...then they are guaranteed to come inâ€¦","html":"<p>Packets in Roblox are ordered and reliable. That means that if you fire off events in this order:</p>\n<div class=\"gatsby-highlight\" data-language=\"lua\"><pre class=\"language-lua\"><code class=\"language-lua\">EventA<span class=\"token punctuation\">:</span><span class=\"token function\">FireServer</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\nEventB<span class=\"token punctuation\">:</span><span class=\"token function\">FireServer</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\nEventC<span class=\"token punctuation\">:</span><span class=\"token function\">FireServer</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>...then they are guaranteed to come in from the server as A, B, and C, in that order.</p>\n<p>This is important, as networking is spotty. Roblox uses UDP (RakNet, as far as I know). UDP, contrasting with TCP, sends whatever packets it has in no defined order and with no guarantee if they'll actually send. This is, of course, a problem in many cases, so reliability layers are stacked on top of it.</p>\n<p><strong>However,</strong> Roblox does not give the developer any control over whether to enable this reliability layer for specific events. This causes a lot of problems in practice, such as making <a href=\"https://developer.valvesoftware.com/wiki/Latency_Compensating_Methods_in_Client/Server_In-game_Protocol_Design_and_Optimization\">great, secure lag compensation impossible</a>, but those examples are more nuanced and tough to grasp for someone who was <em>just</em> introduced to this concept. So here's a very simple, intuitive case for why this functionality is so valued.</p>\n<h2>Fire extinguishers</h2>\n<p>Let's say I want to add fire extinguishers to my game. They put out fires. Simple enough.</p>\n<p>The networking of this fire extinguisher is straight forward:</p>\n<ul>\n<li>Send an event when the player holds down the trigger</li>\n<li>Send an event when the player releases the trigger</li>\n</ul>\n<p>So we hook all that together, and we have a fire extinguisher! But wait...it's only firing one direction. You remember that you want the player to be able to actually AIM your fire extinguisher. Bit trickier, but doable.</p>\n<ul>\n<li>Send an event when the player holds down the trigger</li>\n<li><strong>Send the player's mouse/aim position every tick while the trigger is held down</strong></li>\n<li>Send an event when the player releases the trigger</li>\n</ul>\n<p>Here comes the problem, though. Because events are required to be reliable and ordered, sending the mouse position often is going to completely choke our bandwidth.</p>\n<p>Let's suppose we have fairly spotty internet, which is safe to assume considering how many people play on mobile with data, and see how this can play out:</p>\n<ul>\n<li>FireBegin</li>\n<li>Tick 1: UpdateMouse</li>\n<li>Tick 2: UpdateMouse</li>\n<li>Tick 3: UpdateMouse (this packet is dropped, so we need to send it again)</li>\n<li>Tick 4: UpdateMouse (this packet is delayed to send!)</li>\n<li>Tick 5: UpdateMouse (so is this one!)</li>\n<li>FireEnd (and this one!)</li>\n</ul>\n<p>But here's the thing, we don't care about the UpdateMouse on tick 3 dropping at all! The UpdateMouse on the other ticks would've corrected it anyway. With unreliable packets, this situation would instead look like:</p>\n<ul>\n<li>FireBegin</li>\n<li>Tick 1: UpdateMouse</li>\n<li>Tick 2: UpdateMouse</li>\n<li>Tick 3: UpdateMouse (this packet is dropped, but we don't care!)</li>\n<li>Tick 4: UpdateMouse (this one sends, and corrects the mouse position)</li>\n<li>Tick 5: UpdateMouse</li>\n<li>FireEnd</li>\n</ul>\n<p>The only bits we actually care about being reliable/ordered here are FireBegin and FireEnd. Ensuring those send properly is completely warranted, but delaying every remote event on a mouse update we don't even care about receiving is super bad.</p>","timeToRead":2,"frontmatter":{"date":"2021-09-14","title":"A reliable case for unreliable packets"}}},"pageContext":{"slug":"/a-reliable-case-for-unreliable-packets/"}},
    "staticQueryHashes": ["2428300253"]}